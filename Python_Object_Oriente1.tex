\section{center}{\fontsize{16pt}{16pt}\selectfont \textbf{Python Object Oriented} \\}\end{center} 
Python telah menjadi bahasa berorientasi objek sejak itu ada. Karena itu, menciptakan dan menggunakan kelas dan objek sangat mudah. Bab ini membantu Anda menjadi ahli dalam menggunakan dukungan pemrograman berorientasi objek Python. Jika Anda tidak memiliki pengalaman sebelumnya dengan pemrograman berorientasi objek {OO}, Anda mungkin ingin berkonsultasi dengan kursus perkenalan atau setidaknya tutorial semacam itu sehingga Anda dapat memahami konsep dasarnya. Namun, di sini adalah pengenalan kecil Object-Oriented Programmin {OOP} untuk membawa Anda pada kecepatan - Ikhtisar Terminologi OOP. Kelas: Prototipe yang ditentukan pengguna untuk objek yang mendefinisikan seperangkat atribut yang menjadi ciri objek kelas apa pun. Atribut adalah data anggota {variabel kelas dan variabel contoh} dan metode, diakses melalui notasi titik. Variabel kelas: Variabel yang dimiliki oleh semua instance kelas. Variabel kelas didefinisikan dalam kelas tapi di luar metode kelas manapun. Variabel kelas tidak digunakan sesering variabel contoh. Anggota data: Variabel kelas atau variabel contoh yang menyimpan data yang terkait dengan kelas dan objeknya. Fungsi overloading: Penugasan lebih dari satu perilaku ke fungsi tertentu. Operasi yang dilakukan bervariasi menurut jenis objek atau argumen yang terlibat.Contoh variabel: Variabel yang didefinisikan di dalam metode dan hanya dimiliki oleh instance kelas saat ini. 
Warisan: Pengalihan karakteristik kelas ke kelas lain yang berasal darinya. Contoh: Objek individual dari kelas tertentu. Obyek obj yang termasuk dalam Lingkaran kelas, misalnya, adalah turunan dari Lingkaran kelas. Instansiasi: Pembuatan sebuah instance dari sebuah kelas. Metode: Jenis fungsi khusus yang didefinisikan dalam definisi kelas.  Objek: Contoh unik dari struktur data yang didefinisikan oleh kelasnya. Objek terdiri dari kedua anggota data {variabel kelas dan variabel contoh} dan metode. Operator overloading: Penugasan lebih dari satu fungsi ke operator tertentu. 

\subsection{Pernyataan kelas membuat definisi kelas baru}
Pernyataan kelas membuat definisi kelas baru , Nama kelas segera mengikuti kelas kata kunci diikuti oleh titik dua sebagai berikut 
class ClassName: 
~~ 'Optional class documentation string' 
~~ class \$  \_  \$suite 
\subsubsection {Kelas~memiliki kumpulan dokumentasi}
Kelas~memiliki kumpulan dokumentasi, yang bisa diakses melalui ClassName . \$  \_  \$ \$  \_  \$ doc \$  \_  \$ \$  \_  \$.  Class \$  \_  \$ suite terdiri dari semua pernyataan komponen yang mendefinisikan anggota kelas, atribut dan fungsi data. 
Berikut adalah contoh kelas Python sederhana 
class Employee:
~~ 'Common base class for all employees' 
~~ empCount = 0 
~~ def  \$  \_  \$ \  \_  \$init \$  \_  \$ \$  \_  \${self, name, salary}:  
~~~~~ self.name = name  
~~~~~ self.salary = salary 
~~~~~ Employee.empCount += 1 
~~  
~~ def displayCount(self): \
~~~~ print "Total Employee  \$  \%  \$d"  \$  \%  \$ Employee.empCount 
~~ def displayEmployee(self):
~~~~~~print "Name : ", self.name,  ", Salary: ", self.salary 
Variabel empCount adalah variabel kelas yang nilainya dibagi di antara semua contoh kelas ini. Ini bisa diakses sebagai Employee.empCount dari dalam kelas atau di luar kelas. Metode pertama  \$  \_  \$ \$  \_  \$init  \$  \_  \$ \$  \_  \$  adalah metode khusus, yang disebut metode konstruktor kelas atau inisialisasi yang Python panggil saat Anda membuat instance baru dari kelas ini. Anda menyatakan metode kelas lain seperti fungsi normal dengan pengecualian bahwa argumen pertama untuk setiap metode adalah self. Python menambahkan argumen diri ke daftar untuk Anda; Anda tidak perlu memasukkannya saat Anda memanggil metode. 
{\fontsize{14pt}{14pt}\section \textbf{Membuat Instance Objects} \\} 
Untuk membuat contoh kelas, Anda memanggil kelas menggunakan nama kelas dan meneruskan argumen apa pun yang diterima metode  \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \$-nya. 
"Ini akan menciptakan objek pertama kelas Karyawan" 
Emp1 = Karyawan {"Zara", 2000} 
"Ini akan menciptakan objek kedua dari kelas Karyawan" 
Emp2 = Karyawan {"Manni", 5000} 
{\fontsize{14pt}{14pt}\selectfont \textbf{Mengakses Atribut} \\}
Anda mengakses atribut objek menggunakan dot operator dengan objek. Variabel kelas akan diakses dengan menggunakan nama kelas sebagai berikut 
Emp1.displayEmployee {}
Emp2.displayEmployee {}  
Cetak "Jumlah Karyawan \$  \%  \$ d" \$  \%  \$ Employee.empCount 
Sekarang, meletakkan semua konsep bersama 
 \$  \#  \$!/usr/bin/python 
class Employee: 
~~ 'Common base class for all employees' 
~~ empCount = 0 
~~ def  \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \$(self, name, salary): 
\item 
~~ def displayCount{self}: 
\item 
~~~~ print "Total Employee  \$  \%  \$d"  \$  \%  \$ Employee.empCount 
\begin{12pt}
\item 
~~ def displayEmployee{self}: 
\item 
~~~~~~print "Name : ", self.name,  ", Salary: ", self.salary 
\begin{12pt}
\item
"This would create first object of Employee class" 
\item 
emp1 = Employee{"Zara", 2000} 
\item 
"This would create second object of Employee class"
\item
emp2 = Employee{"Manni", 5000} 
\item
emp1.displayEmployee{} 
\item
emp2.displayEmployee{} 
\item
print "Total Employee  \$  \%  \$d"  \$  \%  \$ Employee.empCount \par
\item
When the above code is executed, it produces the following result  \$ - \$ \par
You can add, remove, or modify attributes of classes and objects at any time  \$ - \$ \par
\noindent 
emp1.age~= 7   \$  \#  \$ Add an 'age' attribute. \par
\noindent 
emp1.age~= 8   \$  \#  \$ Modify 'age' attribute. \par
\noindent 
del~emp1.age   \$  \#  \$ Delete 'age' attribute. \par
\vspace{12pt}
Alih-alih menggunakan pernyataan normal untuk mengakses atribut, Anda dapat menggunakan fungsi berikut - \par
\vspace{12pt}
\noindent 
~~~ Getattr {obj, name [, default]}: untuk mengakses atribut objek. \par
\vspace{12pt}
\noindent 
~~~ Hasattr {obj, name}: untuk memeriksa apakah ada atribut atau tidak. \par
\vspace{12pt}
\noindent 
~~~ Setattr {obj, name, value}: untuk mengatur atribut. Jika atribut tidak ada, maka akan dibuat. \par
\vspace{12pt}
\noindent 
~~~ The delattr {obj, name}: untuk menghapus sebuah atribut. \par
\vspace{12pt}
\noindent 
Hasattr {emp1, 'age'}  \$  \#  \$ Mengembalikan true jika atribut 'age' ada \par
\noindent 
Getattr {emp1, 'age'}  \$  \#  \$ Mengembalikan nilai atribut 'age' \par
\noindent 
Setattr {emp1, 'age', 8}  \$  \#  \$ Set attribute 'age' di 8 \par
\noindent 
Delattr {empl, 'age'}  \$  \#  \$ Hapus atribut 'umur' \par
\begin{12pt}
\centering 
Atribut Atribut Built-In \par
\begin{12pt}
\ centering
Setiap kelas Python terus mengikuti atribut bawaan dan mereka dapat diakses menggunakan operator dot seperti atribut lainnya - 
\begin{12pt}
\bf 
~~~  \$  \_  \$ \$  \_  \$dict \$  \_  \$ \$  \_  \$: Kamus yang berisi namespace kelas. \par
\begin{12pt}
\bf
~~~  \$  \_  \$ \$  \_  \$doc \$  \_  \$ \$  \_  \$: String dokumentasi kelas atau tidak, jika tidak terdefinisi. \par
\begin{12pt}
\bf 
~~~  \$  \_  \$ \$  \_  \$name \$  \_  \$ \$  \_  \$: nama kelas \par
\begin{12pt}
\verb 
~~~  \$  \_  \$ \$  \_  \$module \$  \_  \$ \$  \_  \$: Nama modul dimana kelas didefinisikan. Atribut ini " \$  \_  \$ \$  \_  \$main \$  \_  \$ \$  \_  \$" dalam mode interaktif. \par
\begin{12pt}
\bf 
~~~  \$  \_  \$ \$  \_  \$bases\$  \_  \$ \$  \_  \$: Tupel yang mungkin kosong yang berisi kelas dasar, sesuai urutan kejadiannya dalam daftar kelas dasar. \par
\begin{12pt}
\item
Untuk kelas di atas mari kita coba untuk mengakses semua atribut ini â€“ \par
\begin{12pt}
\bf 
 \$  \#  \$!/usr/bin/python \par
\begin{12pt}
\item 
class Employee: \par
\noindent 
~~ 'Common base class for all employees' \par
\item 
~~ empCount = 0 \par
\begin{12pt}
\bf 
~~ def  \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \{self, name, salar}: \par
\item
~~~~~ self.name = name \par
\item
~~~~~ self.salary = salary \par
\item
~~~~~ Employee.empCount += 1 \par
\item 
~~  \par
\item 
~~ def displayCount(self): \par
\item 
~~~~ print "Total Employee  \$  \%  \$d"  \$  \%  \$ Employee.empCount \par
\begin{12pt}
\item 
~~ def displayEmployee(self): \par
\item 
~~~~~~print "Name : ", self.name,  ", Salary: ", self.salary \par
\begin{12pt}
\bf 
print "Employee. \$  \_  \$ \$  \_  \$doc \$  \_  \$ \$  \_  \$:", Employee. \$  \_  \$ \$  \_  \$doc \$  \_  \$ \$  \_  \$ \par\\
\bf 
print "Employee. \$  \_  \$ \$  \_  \$name \$  \_  \$ \$  \_  \$:", Employee. \$  \_  \$ \$  \_  \$name \$  \_  \$ \$  \_  \$ \par
\noindent 
print "Employee. \$  \_  \$ \$  \_  \$module \$  \_  \$ \$  \_  \$:", Employee. \$  \_  \$ \$  \_  \$module \$  \_  \$ \$  \_  \$ \par
\noindent 
print "Employee. \$  \_  \$ \$  \_  \$bases \$  \_  \$ \$  \_  \$:", Employee. \$  \_  \$ \$  \_  \$bases \$  \_  \$ \$  \_  \$ \par
\noindent 
print "Employee. \$  \_  \$ \$  \_  \$dict \$  \_  \$ \$  \_  \$:", Employee. \$  \_  \$ \$  \_  \$dict \$  \_  \$ \$  \_  \$ \par
\begin{12pt}
\item 
Bila kode diatas dieksekusi, maka menghasilkan hasil sebagai berikut - \par
\vspace{12pt}
\noindent 
Karyawan . \$  \_  \$ \$  \_  \$ doc \$  \_  \$ \$  \_  \$: kelas dasar umum untuk semua karyawan 
\noindent 
Karyawan . \$  \_  \$ \$  \_  \$ name \$  \_  \$ \$  \_  \$: Karyawan \par
\noindent 
Karyawan . \$  \_  \$ \$  \_  \$ modul \$  \_  \$ \$  \_  \$:  \$  \_  \$ \$  \_  \$main \$  \_  \$ \$  \_  \$ \par
\noindent 
Karyawan . \$  \_  \$ \$  \_  \$ bases \$  \_  \$ \$  \_  \$: () \par
\noindent 
Karyawan . \$  \_  \$ \$  \_  \$ dict \$  \_  \$ \$  \_  \$:  \$  \{  \$' \$  \_  \$ \$  \_  \$module \$  \_  \$ \$  \_  \$': ' \$  \_  \$ \$  \_  \$main \$  \_  \$ \$  \_  \$', 'displayCount': \par
\noindent 
<function displayCount at 0xb7c84994>, 'empCount': 2, 
\noindent 
'DisplayEmployee': <function displayEmployee at 0xb7c8441c>, 
\noindent 
' \$  \_  \$ \$  \_  \$doc \$  \_  \$ \$  \_  \$': 'Kelas dasar umum untuk semua karyawan', 
\noindent 
' \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \$': <function  \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \$ di 0xb7c846bc> \$  \}  \$ 
\vspace{12pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont \textbf{Menghancurkan Objek (Pengumpulan Sampah)} \\} \par
\vspace{12pt}
Python menghapus objek yang tidak dibutuhkan (tipe built-in atau instance kelas) secara otomatis untuk membebaskan ruang memori. Proses dimana Python secara berkala mengumpulkan kembali blok memori yang tidak lagi digunakan disebut Koleksi Sampah. Pengumpul sampah Python berjalan selama eksekusi program dan dipicu saat penghitungan referensi objek mencapai nol. Jumlah referensi referensi berubah karena jumlah alias yang menunjukkannya berubah. Jumlah referensi objek meningkat saat diberi nama baru atau ditempatkan dalam wadah (daftar, tupel, atau kamus). Jumlah referensi objek berkurang saat dihapus dengan del, rujukannya ditugaskan kembali, atau rujukannya tidak sesuai. Ketika penghitungan referensi objek mencapai nol, Python mengumpulkannya secara otomatis. \par
\vspace{12pt}
\noindent 
a = 40  \$  \#  \$ Buat objek <40> \par
\noindent 
B = a  \$  \#  \$ Tingkatkan ref. Hitung <40> \par
\noindent 
c = [b]  \$  \#  \$ Tingkatkan ref. Hitung <40> \par
\vspace{12pt}
\noindent 
Del  \$  \#  \$ Penurunan ref. Hitung <40> \par
\noindent 
b = 100  \$  \#  \$ Kurangi ref. Hitung <40> \par
\noindent 
C [0] = -1  \$  \#  \$ Kurangi ref. Hitung <40> \par
\vspace{12pt}
Anda biasanya tidak akan memperhatikan kapan pengumpul sampah menghancurkan contoh yatim piatu dan mengembalikan ruangnya. Tapi kelas bisa menerapkan metode khusus  \$  \_  \$ \$  \_  \$del  \$  \_  \$ \$  \_  \$ {}, yang disebut destructor, yang dipanggil saat instance tersebut hendak dimusnahkan. Metode ini bisa digunakan untuk membersihkan sumber daya non memori yang digunakan oleh sebuah instance. \par
\noindent 
Contoh \par
\vspace{12pt}
\item
Penghancur  \$  \_  \$ \$  \_  \$del  \$  \_  \$ \$  \_  \$ {} ini mencetak nama kelas sebuah instance yang akan dihancurkan - 
\bf
 \$  \#  \$!/usr/bin/python \par
\vspace{12pt}
\noindent 
class Point: \par
\noindent 
~~ def  \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \$( self, x=0, y=0): \par
\noindent 
~~~~~ self.x = x \par
\noindent 
~~~~~ self.y = y \par
\noindent 
~~ def  \$  \_  \$ \$  \_  \$del \$  \_  \$ \$  \_  \${self}: \par
\noindent 
~~~~~ class \$  \_  \$name = self. \$  \_  \$ \$  \_  \$class \$  \_  \$ \$  \_  \$. \$  \_  \$ \$  \_  \$name \$  \_  \$ \$  \_  \$ \par
\item
~~~~~ print class \$  \_  \$name, "destroyed" \par
\vspace{12pt}
\noindent 
pt1 = Point{} \par
\noindent 
pt2 = pt1 \par
\noindent 
pt3 = pt1 \par
\noindent 
print id{pt1}, id{pt2}, id{pt3}  \$  \#  \$ prints the ids of the obejcts \par
\noindent 
del pt1 \par
\noindent 
del pt2 \par
\noindent 
del pt3 \par
\vspace{12pt}
\vspace{12pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont \textbf{Kelas Warisan} \\} \par
\begin{12pt}
Alih-alih mulai dari nol, Anda dapat membuat kelas dengan menurunkannya dari kelas yang sudah ada sebelumnya dengan mencantumkan kelas induk dalam tanda kurung setelah nama kelas yang baru. Kelas anak mewarisi atribut kelas induknya, dan Anda dapat menggunakan atribut tersebut seolah-olah mereka didefinisikan di kelas anak. Kelas anak juga dapat mengesampingkan data anggota dan metode dari orang tua. Sintaksis Kelas turunan dinyatakan seperti kelas orang tua mereka; Namun, daftar kelas dasar yang diwarisi dari diberikan setelah nama kelas - \par
\vspace{12pt}
\noindent 
Kelas SubClassName {ParentClass1 [, ParentClass2, ...]}: \par
\noindent 
~~ 'String dokumentasi kelas opsional' \par
\noindent 
~~ Class \$  \_  \$suite \par
\noindent 
 \$  \#  \$!/usr/bin/python \par
\vspace{12pt}
\noindent 
class~Parent:~~~~~~   \$  \#  \$ define parent class \par
\noindent 
~~ parentAttr = 100 \par
\noindent 
~~ def  \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \${self}: \par
\noindent 
~~~~~ print "Calling parent constructor" \par
\vspace{12pt}
\noindent 
~~ def parentMethod{self}: \par
\noindent 
~~~~~ print 'Calling parent method' \par
\begin{12pt}
\noindent 
~~ def setAttr{self, attr}: \par
\noindent 
~~~~~ Parent.parentAttr = attr \par
\begin{12pt}
\noindent 
~~ def getAttr{self}: \par
\noindent 
~~~~~ print "Parent attribute :", Parent.parentAttr \par
\vspace{12pt}
\noindent 
class Child(Parent):  \$  \#  \$ define child class \par
\noindent 
~~ def  \$  \_  \$ \$  \_  \$init \$  \_  \$ \$  \_  \$(self): \par
\noindent 
~~~~~ print "Calling child constructor" \par
\vspace{12pt}
\noindent 
~~ def childMethod(self): \par
\noindent 
~~~~~ print 'Calling child method' \par
\vspace{12pt}
\noindent 
c~=~Child()~~~~~~~    \$  \#  \$ instance of child \par
\noindent 
c.childMethod()~~~~~  \$  \#  \$ child calls its method \par
\noindent 
c.parentMethod()~~~~  \$  \#  \$ calls parent's method \par
\noindent 
c.setAttr(200)~~~~~~  \$  \#  \$ again call parent's method \par
\noindent 
c.getAttr()~~~~~~~~~  \$  \#  \$ again call parent's method \par
\vspace{12pt}
\noindent 
Calling child constructor \par
\noindent 
Calling child method \par
\noindent 
Calling parent method \par
\noindent 
Parent attribute : 200 \par
\vspace{12pt}
\noindent 
class~A:~~~~~~   \$  \#  \$ define your class A \par
\noindent 
..... \par
\vspace{12pt}
\noindent 
class~B:~~~~~~~   \$  \#  \$ define your class B \par
\noindent 
..... \par
\vspace{12pt}
\noindent 
class~C(A,~B):    \$  \#  \$ subclass of A and B \par
\vspace{12pt}
Anda dapat menggunakan fungsi issubclass () atau isinstance () untuk memeriksa hubungan dua kelas dan contoh. Fungsi boolean issubclass (sub, sup) mengembalikan true jika sub subclass yang diberikan memang merupakan subclass dari superclass sup. The isinstance (obj, Class) fungsi boolean mengembalikan true jika obj adalah turunan dari Class Class atau merupakan instance dari subclass of Class. \par
\vspace{12pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont \textbf{Metode utama} \\} \par
\vspace{12pt}
Anda selalu dapat mengganti metode kelas induk Anda. Salah satu alasan untuk mengesampingkan metode orang tua adalah karena Anda mungkin menginginkan fungsi khusus atau berbeda di subkelas Anda. \par
Contoh \par
\vspace{12pt}
\noindent 
 \$  \#  \$! / Usr / bin / python \par
\vspace{12pt}
\noindent 
class parent:  \$  \#  \$ define parent class \par
\noindent 
~~ Def myMethod (diri): \par
\noindent 
~~~~~ Cetak 'metode induk panggilan' \par
\vspace{12pt}
\noindent 
Kelas anak (orang tua):  \$  \#  \$ define child class \par
\noindent 
~~ Def myMethod (diri): \par
\noindent 
~~~~~ Cetak 'metode memanggil anak' \par
\vspace{12pt}
\noindent 
C = Anak ()  \$  \#  \$ contoh anak \par
\noindent 
C.myMethod ()  \$  \#  \$ metode panggilan balik anak \par
\vspace{12pt}
\noindent 
Bila kode diatas dieksekusi, maka menghasilkan hasil sebagai berikut - \par
\vspace{12pt}
\noindent 
Memanggil metode anak \par
\vspace{12pt}
\noindent 
Metode Base Overloading \par
\vspace{12pt}
\noindent 
Berikut daftar tabel beberapa fungsionalitas generik yang dapat Anda timpa di kelas Anda sendiri - \par
\vspace{14pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont \textbf{Operator overloading} \\} \par
\vspace{12pt}
Misalkan Anda telah membuat kelas Vektor untuk mewakili vektor dua dimensi, apa yang terjadi bila Anda menggunakan operator plus untuk menambahkannya? Kemungkinan besar Python akan berteriak pada Anda. Anda bisa, bagaimanapun, menentukan metode  \$  \_  \$ \$  \_  \$add \$  \_  \$ \$  \_  \$ di kelas Anda untuk melakukan penambahan vektor dan operator plus akan berperilaku sesuai harapan - \par
Contoh \par
\vspace{12pt}
\noindent 
 $  \#  $! / Usr / bin / python \par
\vspace{12pt}
\noindent 
Kelas vektor: \par
\noindent 
~~ def  $  \_  $ $  \_  $init  $  \_  $ $  \_  $ (diri, a, b): \par
\noindent 
~~~~~ Self.a = a \par
\noindent 
~~~~~ Self.b = b \par
\vspace{12pt}
\noindent 
~~ def  $  \_  $ $  \_  $str  $  \_  $ $  \_  $ (diri): \par
\noindent 
~~~~~ Return 'Vector ( $  \%  $ d, $  \%  $ d)' $  \%  $ (self.a, self.b) \par
\noindent 
~~  \par
\noindent 
~~ Def  $  \_  $ $  \_  $add  $  \_  $ $  \_  $ (diri sendiri, lainnya): \par
\noindent 
~~~~~ return Vector (self.a + other.a, self.b + other.b) \par
\vspace{12pt}
\noindent 
v1 = vektor (2,10) \par
\noindent 
v2 = vektor (5, -2) \par
\noindent 
cetak v1 + v2 \par
\vspace{12pt}
\noindent 
Bila kode diatas dieksekusi, maka menghasilkan hasil sebagai berikut - \par
\vspace{12pt}
\noindent 
Vektor (7,8) \par
\vspace{12pt}
\noindent 
{\fontsize{14pt}{14pt}\selectfont \textbf{Persembunyian data} \\} \par
\vspace{12pt}
Atribut objek mungkin atau mungkin tidak terlihat di luar definisi kelas. Anda perlu memberi nama atribut dengan awalan ganda ganda, dan atribut tersebut kemudian tidak langsung terlihat oleh orang luar. \par
Contoh \par
\vspace{12pt}
\noindent 
 $  \#  $! / Usr / bin / python \par
\vspace{12pt}
\noindent 
Kelas JustCounter: \par
\noindent 
~~  $  \_  $ $  \_  $secretCount = 0 \par
\noindent 
~  \par
\noindent 
~~ def menghitung (diri): \par
\noindent 
~~~~~ self . $  \_  $ $  \_  $ secretCount + = 1 \par
\noindent 
~~~~~ cetak diri . $  \_  $ $  \_  $ secretCount \par
\vspace{12pt}
\noindent 
counter = JustCounter () \par
\noindent 
Counter.count () \par
\noindent 
Counter.count () \par
\noindent 
print counter . $  \_  $ $  \_  $ secretCount \par
\vspace{12pt}
\noindent 
Bila kode diatas dieksekusi, maka menghasilkan hasil sebagai berikut - \par
\vspace{12pt}
\noindent 
1 \par
\noindent 
2 \par
\noindent 
Traceback (panggilan terakhir): \par
\noindent 
~ File "test.py", baris 12, di <module> \par
\noindent 
~~~ print counter . $  \_  $ $  \_  $ secretCount \par
\noindent 
AttributeError: instance JustCounter tidak memiliki atribut ' $  \_  $ $  \_  $secretCount' \par
\vspace{12pt}
Python melindungi anggota tersebut dengan mengganti namanya secara internal untuk memasukkan nama kelas. Anda dapat mengakses atribut seperti object. $  \_  $className $  \_  $ $  \_  $attrName. Jika Anda akan mengganti baris terakhir Anda sebagai berikut, maka akan berhasil untuk Anda - \par
\vspace{12pt}
\noindent 
print counter. $  \_  $JustCounter $  \_  $ $  \_  $secretCount \par
\vspace{12pt}
\noindent 
Bila kode diatas dieksekusi, maka menghasilkan hasil sebagai berikut - \par
\vspace{12pt}
\noindent 
1 \par
\noindent 
2 \par
\noindent 
2 \par
\vspace{12pt}
Contoh \par
\vspace{12pt}
Kelas bisa mewarisi kelas lainnya. Kelas dapat mewarisi atribut dan perilaku (metode) dari kelas lain, yang disebut kelas super. Sebuah kelas yang mewarisi dari kelas super disebut Sub-kelas. Kelas super kadang disebut nenek moyang juga. Ada hubungan hierarki antar kelas. Jika kita melihat lebih dekat contoh sebelumnya tentang akun kelas, kita dapat melihat bahwa model ini dapat memenuhi kebutuhan bank sebenarnya. Bank biasanya memiliki jenis akun yang berbeda, mis. Rekening Tabungan, Rekening Giro dan lain-lain. Meskipun jenis akun yang berbeda ini sangat berbeda, namun tetap memiliki banyak sifat dan metode yang sama. Misalnya. Setiap akun memiliki dan membutuhkan nomor rekening, pemegang dan saldo. Selanjutnya mungkin bagi masing-masing untuk menyetor atau menarik uang. \par
Jadi, ada sesuatu seperti akun "mendasar" darimana mereka mewarisi. Warisan digunakan untuk membuat kelas baru dengan menggunakan kelas yang ada. Yang baru dapat diciptakan dengan memperluas dan dengan membatasi kelas yang ada. \par
Sekarang saatnya untuk kembali ke Python dan melihat bagaimana kelas diimplementasikan dengan Python. Kita mulai dengan kelas yang paling sederhana, yang bisa didefinisikan. Kami hanya memberikan nama tapi menghilangkan semua spesifikasi lebih lanjut dengan menggunakan kata kunci n. \par
\vspace{12pt}
\noindent 
Class Account (objek): \par
\vspace{12pt}
\noindent 
Kami belum mendefinisikan atribut atau metode apa pun di kelas akun sederhana kami. Sekarang kita akan membuat sebuah instance dari kelas kosong ini: \par
\vspace{12pt}
\vspace{12pt}
\vspace{12pt}
\vspace{12pt}
\noindent 
>>> dari Account import Account \par
\noindent 
>>> x = Akun () \par
\noindent 
>>> cetak x \par
\noindent 
<Account.Account objek di 0x7f364120ab90> \par
\noindent 
>>> \par
\vspace{12pt}
\noindent 
Sebuah metode berbeda dari satu fungsi saja dalam dua aspek: \par
\noindent 
Itu milik kelas dan itu didefinisikan dalam kelas \par
\noindent 
Parameter pertama dalam definisi suatu metode harus menjadi referensi "diri" pada instance kelas \par
\noindent 
Sebuah metode disebut tanpa parameter ini "diri" \par
\vspace{12pt}
Kami memperluas kelas kami dengan mendefinisikan beberapa metode. Tubuh dari metode ini masih belum ditentukan: \par
\vspace{12pt}
\noindent 
kelas Account (objek): \par
\vspace{12pt}
\noindent 
~~~ Transfer def (self, target, amount): \par
\noindent 
~~~~~~~ lulus \par
\noindent 
  \par
\noindent 
~~~ Def deposit (self, amount): \par
\noindent 
~~~~~~~ lulus \par
\noindent 
  \par
\noindent 
~~~ Def withdraw (self, amount): \par
\noindent 
~~~~~~~ lulus \par
\noindent 
  \par
\noindent 
~~~ def keseimbangan (diri): \par
\noindent 
~~~~~~~ lulus \par
\vspace{12pt}
\noindent 
Python tidak memiliki konstruktor eksplisit seperti C ++ atau Java, tapi metode  $  \_  $ $  \_  $init  $  \_  $ $  \_  $ () dengan Python adalah sesuatu yang serupa, meskipun sebenarnya bukan konstruktor. Ini berperilaku dalam banyak hal seperti konstruktor, mis. Ini adalah kode pertama yang dijalankan, saat instance baru dari sebuah kelas dibuat. Nama itu terdengar seperti konstruktor " $  \_  $ $  \_  $init $  \_  $ $  \_  $". Tapi secara tegas, akan salah jika menyebutnya sebagai konstruktor, karena contoh baru sudah "dibangun" pada saat metode  $  \_  $ $  \_  $init $  \_  $ $  \_  $ dipanggil. Tapi bagaimanapun, metode  $  \_  $ $  \_  $init $  \_  $ $  \_  $ digunakan - seperti konstruktor pada bahasa pemrograman berorientasi objek lainnya - untuk menginisialisasi variabel instance dari sebuah objek. Definisi metode init terlihat seperti definisi metode lainnya: \par
\vspace{12pt}
\vspace{12pt}
\noindent 
Def  $  \_  $ $  \_  $init  $  \_  $ $  \_  $ (self, holder, number, balance, credit $  \_  $line = 1500): \par
\noindent 
~~~~~~~ self.Holder = pemegang \par
\noindent 
~~~~~~~ Nomor self.Number = \par
\noindent 
~~~~~~~ self.Balance = keseimbangan \par
\noindent 
~~~~~~~ self.CreditLine = credit $  \_  $line \par
\vspace{12pt}
Apa yang kami katakan tentang konstruktor berlaku bagi penghancur juga. Tidak ada destruktor "nyata", tapi ada yang serupa, yaitu metode  $  \_  $ $  \_  $del $  \_  $ $  \_  $. Hal ini disebut ketika contoh ini akan hancur. Jika kelas dasar memiliki metode  $  \_  $ $  \_  $del  $  \_  $ $  \_  $ (), metode  $  \_  $ $  \_  $del  $  \_  $ $  \_  $ () kelas turunan, jika ada, harus secara eksplisit memanggilnya untuk memastikan penghapusan komponen kelas dasar contoh yang tepat. \par
\noindent 
Contoh berikut menunjukkan kelas dengan konstruktor dan destruktor: \par
\vspace{12pt}
\vspace{12pt}
\noindent 
Kelas Salam: \par
\noindent 
~~~ Def  $  \_  $ $  \_  $init  $  \_  $ $  \_  $ (diri, nama): \par
\noindent 
~~~~~~~ self.name = nama \par
\noindent 
~~~ Def  $  \_  $ $  \_  $del  $  \_  $ $  \_  $ (diri): \par
\noindent 
~~~~~~~ Cetak "Destructor dimulai" \par
\noindent 
~~~ Def SayHello (diri): \par
\noindent 
~~~~~~~ Cetak "Halo", self.name \par
\vspace{12pt}
